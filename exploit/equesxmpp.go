package main

import "fmt"
import "time"
import "flag"
import "os"
import "strings"
import "strconv"
import "crypto/aes"
import "crypto/md5"
import "encoding/hex"
import "encoding/base64"

func thisTime()(epochTime int64, parsedTime string) {
	now := time.Now()
	epochTime = now.Unix()
	parsedTime = fmt.Sprintf("%d-%02d-%02d-%02d:%02d:%02d", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())
	return
}

//AES 256 Encryption using the key fdsl;mewrjope456fds4fbvfnjwaugfo
func aesEcb256Encrypt(parsedCommand string) (string) {
        key, _ := hex.DecodeString("6664736c3b6d6577726a6f706534353666647334666276666e6a77617567666f")

        bs := 16

	var plaintext []byte
	nopadplaintext := []byte(parsedCommand)
        pad := bs - len(nopadplaintext) % bs

	if pad != 16 {
		paddedlength := len(nopadplaintext) + pad
		paddedplaintext := make([]byte, paddedlength)
		copy(paddedplaintext, nopadplaintext)

		plaintext = paddedplaintext

	} else {
		plaintext = []byte(parsedCommand)
		}

        block, err := aes.NewCipher(key)
        if err != nil {
                panic(err)
        }

        ciphertext := make([]byte, len(plaintext))
	be := 0
        for len(plaintext) > 0 {
                block.Encrypt(ciphertext[be:], plaintext)
                plaintext = plaintext[bs:]
                be += bs
        }
	return base64.StdEncoding.EncodeToString([]byte(ciphertext))
}

//AES 256 Encryption using the generated device specific key
func aesEcb256EncryptKonke(parsedCommand string, deviceKey string) (string) {
        key, _ := hex.DecodeString(deviceKey)

        bs := 16

	var plaintext []byte
	nopadplaintext := []byte(parsedCommand)
        pad := bs - len(nopadplaintext) % bs

	if pad != 16 {
		paddedlength := len(nopadplaintext) + pad
		paddedplaintext := make([]byte, paddedlength)
		copy(paddedplaintext, nopadplaintext)

		plaintext = paddedplaintext

	} else {
		plaintext = []byte(parsedCommand)
		}

        block, err := aes.NewCipher(key)
        if err != nil {
                panic(err)
        }

        ciphertext := make([]byte, len(plaintext))
	be := 0
        for len(plaintext) > 0 {
                block.Encrypt(ciphertext[be:], plaintext)
                plaintext = plaintext[bs:]
                be += bs
        }
	return base64.StdEncoding.EncodeToString([]byte(ciphertext))
}


//AES 256 Decryption using the key fdsl;mewrjope456fds4fbvfnjwaugfo
func aesEcb256Decrypt(commandResponse string) (string) {
        key, _ := hex.DecodeString("6664736c3b6d6577726a6f706534353666647334666276666e6a77617567666f")

        bs := 16

	var ciphertext []byte
	nopadciphertext, _ := hex.DecodeString(commandResponse)
        pad := bs - len(nopadciphertext) % bs

	if pad != 16 {
		paddedlength := len(nopadciphertext) + pad
		paddedciphertext := make([]byte, paddedlength)
		copy(paddedciphertext, nopadciphertext)

		ciphertext = paddedciphertext

	} else {
		ciphertext, _ = hex.DecodeString(commandResponse)
		}

        block, err := aes.NewCipher(key)
        if err != nil {
                panic(err)
        }

        plaintext := make([]byte, len(ciphertext))
	be := 0
        for len(ciphertext) > 0 {
			block.Decrypt(plaintext[be:], ciphertext)
            ciphertext = ciphertext[bs:]
            be += bs
        }
	return string(plaintext)
}

//Function to generate the device specific key
func getDeviceKey(mac string, pass string) (string) {

	parsedMac := strings.Replace(mac, "-", "", -1)

	devicePass := []byte(pass)
	startKey := []byte("w5%45j!a")
	endKey := []byte(",~j33in3lea^~rw2]ryxes8y")

	for i := 0; i < len(devicePass); i++ {
		startKey[i] = devicePass[i] | startKey[i]
		if startKey[i] > 126 {
			startKey[i] = 114
		}
	}

	endKey[6] = parsedMac[6]
	endKey[7] = parsedMac[7]
	endKey[10] = parsedMac[8]
	endKey[11] = parsedMac[9]
	endKey[14] = parsedMac[10]
	endKey[15] = parsedMac[11]

	combinedKey := string(startKey)+string(endKey)

	keyHash := md5.Sum([]byte(combinedKey))
	finalKey := hex.EncodeToString(keyHash[:])

	finalEncodedKey := hex.EncodeToString([]byte(finalKey))

	return finalEncodedKey
}

func main() {

	epochTime, _ := thisTime()
	var command string
	var fullCommand string
	var commandPrefix string
	phonemacPtr := flag.String("phonemac", "", "Mac address of the phone in the format aa-bb-cc-dd-ee-ff")
	devicemacPtr := flag.String("devicemac", "", "Mac address of the smart power plug in the format aa-bb-cc-dd-ee-ff")
	commandPtr := flag.String("command", "", "Either of: [on; off](devicemac and pass needed)")
	passPtr := flag.String("pass", "", "pass: Password of the smart power plug")

	flag.Parse()

	if *commandPtr == "" {
		fmt.Println("the command must be specified\n")
		flag.PrintDefaults()
		os.Exit(1)
	}

	if *devicemacPtr == "" {
		fmt.Println("the mac address of the smart power plug must be specified\n")
		flag.PrintDefaults()
		os.Exit(1)
	}

	if *passPtr == "" {
		fmt.Println("the password of the smart power plug must be specified\n")
		flag.PrintDefaults()
		os.Exit(1)
	}

	switch *commandPtr {

		case "on":
        	command = "open%"+strconv.FormatInt(int64(epochTime), 10)

        case "off":
        	command = "close%"+strconv.FormatInt(int64(epochTime), 10)

        case "getkey":
        	fmt.Println(getDeviceKey(*devicemacPtr, *passPtr))

    	default:
    		fmt.Println("Wrong command argument(s) specified\n")
    		flag.PrintDefaults()
    		os.Exit(1)
    }

    deviceKey := getDeviceKey(*devicemacPtr, *passPtr)
    ciphertext := aesEcb256EncryptKonke(command, deviceKey)
    fmt.Println("Device Key:", deviceKey)
	fmt.Println("Plaintext Command:", command)
	fmt.Println("Encrypted Command:", ciphertext)

	fullCommand = "wan_phone%"+*phonemacPtr+"eques%"+*passPtr+"%"+ciphertext+"%relay"
    commandPrefix = "encryption:"
    fullCiphertext := aesEcb256Encrypt(fullCommand)
	fmt.Println("Full Command:", fullCommand+"\n")
	fmt.Println(commandPrefix+fullCiphertext+"\n")
}